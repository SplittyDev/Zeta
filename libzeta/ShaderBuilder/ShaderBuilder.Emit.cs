using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

namespace libzeta {
    
    public abstract partial class ShaderBuilder {

        int indent;
        bool reindent;

        void Indent () => indent += 3;
        void Unindent () => indent = Math.Max (0, indent - 3);

        protected Dictionary<Type, Struct> structCache;

        public static string Build<T> () where T : ShaderBuilder, new() {
            var instance = new T ();
            return instance.Build ();
        }

        public string Build () {
            try {
                return BuildInternal ();
            } catch (Exception e) {
                this.Log (LoggingLevel.ERROR, e.Message);
            }
            return builder.ToString ();
        }

        string BuildInternal () {
            BuildVersion ();
            BuildString ("// automatically generated by zeta\n");
            BuildVariables (GetType ());
            BuildMethods (GetType ());
            return builder.ToString ();
        }

        void BuildString (string code) {
            var indentString = reindent ? string.Empty.PadLeft (indent, ' ') : string.Empty;
            builder.Append ($"{indentString}{code}");
            reindent = code.EndsWith ("\n", StringComparison.Ordinal);
        }

        void BuildVersion () {

            // Get the GLSLVersion attribute
            var glslVersion = GetType ().GetCustomAttribute<GLSLVersion> ();

            // Add the version to the shader source
            BuildString ($"#version {glslVersion?.Version ?? 400}\n");
        }
    
        void BuildVariables (Type type) {

            // Iterate over the non-public nested types
            foreach (var clazz in type.GetNestedTypes (generalFlags)) {

                // Test if the field type intherits from Struct
                if (!clazz.IsSubclassOf (typeof (Struct)))
                    continue;

                // Build the struct
                BuildStruct (clazz);
            }

            // Iterate over the non-public instance fields
            foreach (var field in type.GetFields (generalFlags)) {
                object invoker = this;
                var declType = field.GetCustomAttribute<GLSLDeclarationType> ()?.ToString () ?? string.Empty;

                // Test if the field type inherits from Struct
                if (field.FieldType.IsSubclassOf (typeof (Struct))) {
                    BuildStructUsage (field);
                    field.SetValue (invoker, structCache [field.FieldType]);
                    continue;
                }

                // Test if the field type inherits from GLSLObject
                if (!field.FieldType.IsSubclassOf (typeof (GLSLObject)))
                    continue;

                // Initialize the variable
                var init = new GLSLInitializer (field.Name);
                field.SetValue (invoker, GetGLSLTypeFromInitializer (init, field.FieldType));

                // Get the value of the field as GLSLObject
                var val = field.GetValue (this) as GLSLObject;

                // Set the name of the variable
                val.SetName (field.Name);

                // Add the field to the shader source
                BuildString ($"{declType} {val.TypeName} {val.Name};\n");
            }
        }

        void BuildStruct (Type structType) {

            // Create an instance of the struct
            var structInstance = (Struct) Activator.CreateInstance (structType);
            structCache [structType] = structInstance;

            // Add the struct signature to the shader source
            BuildString ($"struct {structType.Name} {{\n");
            Indent ();

            // Iterate over the non-public instance fields
            foreach (var field in structType.GetFields (generalFlags)) {

                // Test if the field type inherits from GLSLObject
                if (!field.FieldType.IsSubclassOf (typeof (GLSLObject)))
                    continue;

                // Initialize the variable
                var init = new GLSLInitializer (field.Name);
                field.SetValue (structInstance, GetGLSLTypeFromInitializer (init, field.FieldType));

                // Ge the value of the field as GLSLObject
                var val = field.GetValue (structInstance) as GLSLObject;

                // Set the name of the variable
                val.SetName (field.Name);
                val.owningStruct = structInstance;

                // Add the field to the shader source
                BuildString ($"{val.TypeName} {val.Name};\n");
            }

            // Exit the scope of the struct
            Unindent ();
            BuildString ("}\n");
        }

        void BuildStructUsage (FieldInfo field) {

            // Get the declaration type of the variable
            var declType = field.GetCustomAttribute<GLSLDeclarationType> ()?.ToString () ?? string.Empty;

            // Add the variable definition to the shader source
            BuildString ($"{declType} {field.FieldType.Name} {field.Name};\n");

            // Add the name of the variable to the cached struct instance
            structCache [field.FieldType].FieldName = field.Name;
        }

        void BuildMethods (Type type) {

            // Iterate over the non-public instance methods
            foreach (var method in type.GetMethods (generalFlags)) {

                // Skip the method if it is a lambda
                if (method.Name.StartsWith ("<", StringComparison.Ordinal)) {
                    continue;
                }

                // Get the return type of the method as GLSL type
                var returnTypeString = GetGLSLType (method.ReturnType);

                // Get the parameters of the method as GLSL parameters
                var parameterList = GetGLSLParameterList (method);

                // Add the function signature to the shader source
                BuildString ($"{returnTypeString} {method.Name} ({parameterList}) {{\n");
                Indent ();

                // Invoke the method
                var invokeParameters = new object [method.GetParameters ().Length];
                for (var i = 0; i < method.GetParameters ().Length; i++) {
                    var parameter = method.GetParameters () [i];
                    invokeParameters [i] = GetGLSLParameterInstance (parameter);
                }
                method.Invoke (this, invokeParameters);

                // Exit the scope of the function
                Unindent ();
                BuildString ("}\n");
            }
        }

        string GetGLSLParameterList (MethodInfo method) {

            // Create the string buffer
            var accum = new StringBuilder ();

            // Iterate over the parameters of the method
            var i = 0;
            foreach (var parameter in method.GetParameters ()) {

                // Get the type of the parameter as GLSL type
                var parameterTypeString = GetGLSLType (parameter.ParameterType);

                // Add the parameter type and the parameter name to the shader source
                accum.Append ($"{parameterTypeString} {parameter.Name}");
                if (++i < method.GetParameters ().Length) {
                    accum.Append (", ");
                }
            }

            // Return the parameter list
            return accum.ToString ();
        }

        string GetGLSLType (Type type) {
            switch (type.Name.ToLowerInvariant ()) {
                case "glfloat": return "float";
                case "sampler2d": return "sampler2D";
            }
            return type.Name.ToLowerInvariant ();
        }

        GLSLObject GetGLSLTypeFromInitializer (GLSLInitializer init, Type type) {
            switch (type.Name.ToLowerInvariant ()) {
                case "vec2": return (Vec2)init;
                case "vec3": return (Vec3)init;
                case "vec4": return (Vec4)init;
                case "mat4": return (Mat4)init;
                case "glfloat": return (GLFloat)init;
                case "sampler2d": return (Sampler2D)init;
                case "struct": return (Struct)init;
            }
            return (GLSLObject)init;
        }

        object GetGLSLParameterInstance (ParameterInfo parameter) {
            if (parameter.ParameterType.IsSubclassOf (typeof (GLSLObject))) {
                switch (parameter.ParameterType.Name.ToLowerInvariant ()) {
                    case "vec2": return new Vec2 (parameter.Name);
                    case "vec3": return new Vec3 (parameter.Name);
                    case "vec4": return new Vec4 (parameter.Name);
                    case "mat4": return new Mat4 (parameter.Name);
                    case "glfloat": return new GLFloat (parameter.Name);
                    case "sampler2D": return new Sampler2D (parameter.Name);
                }
                return new GLSLObject (parameter.Name);
            }
            return null;
        }
    }
}

